package main

import (
	"bufio"
	"fmt"
	"log"
	"os/exec"
	"regexp"
	"strings"
	"time"
)

type Commit struct {
	Hash     string `yaml:"hash"`
	FullHash string // Internal use for tag matching
	Date     string `yaml:"date"`
	Subject  string `yaml:"subject"`
	Author   string `yaml:"author"`
	Type     string `yaml:"type"`
	Tag      string `yaml:"tag,omitempty"`
}

type Release struct {
	Tag     string   `yaml:"tag"`
	Hash    string   `yaml:"hash"`
	Date    string   `yaml:"date"`
	Subject string   `yaml:"subject"`
	Author  string   `yaml:"author"`
	Commits []Commit `yaml:"commits"`
}

func main() {
	commits, err := getCommits()
	if err != nil {
		log.Fatalf("Error getting commits: %v", err)
	}

	// Get tags and associate with commits
	tags, err := getTags()
	if err != nil {
		log.Fatalf("Error getting tags: %v", err)
	}

	// Associate tags with commits
	for i := range commits {
		if tag, exists := tags[commits[i].FullHash]; exists {
			commits[i].Tag = tag
		}
	}

	// Group commits by release
	releaseCommits := groupCommitsByRelease(commits, tags)

	// Group commits by type for better organization
	commitsByType := groupCommitsByType(commits)

	// Generate YAML output
	fmt.Println("# Generated by changelog-generator")
	fmt.Printf("# Generated on: %s\n", time.Now().Format("2006-01-02 15:04:05"))
	fmt.Println()

	// Output releases with their commits
	fmt.Println("releases:")
	if len(releaseCommits) == 0 {
		fmt.Println("  # No tagged releases found")
		fmt.Println()
	} else {
		for _, release := range releaseCommits {
			fmt.Printf("- tag: \"%s\"\n", release.Tag)
			fmt.Printf("  hash: \"%s\"\n", release.Hash)
			fmt.Printf("  date: \"%s\"\n", release.Date)
			fmt.Printf("  subject: \"%s\"\n", release.Subject)
			fmt.Printf("  author: \"%s\"\n", release.Author)
			fmt.Printf("  commits:\n")
			for _, commit := range release.Commits {
				fmt.Printf("  - hash: \"%s\"\n", commit.Hash)
				fmt.Printf("    date: \"%s\"\n", commit.Date)
				fmt.Printf("    subject: \"%s\"\n", commit.Subject)
				fmt.Printf("    author: \"%s\"\n", commit.Author)
				fmt.Printf("    type: \"%s\"\n", commit.Type)
			}
			fmt.Println()
		}
	}

	// Output all commits
	fmt.Println("commits:")
	for _, commit := range commits {
		fmt.Printf("- hash: \"%s\"\n", commit.Hash)
		fmt.Printf("  date: \"%s\"\n", commit.Date)
		fmt.Printf("  subject: \"%s\"\n", commit.Subject)
		fmt.Printf("  author: \"%s\"\n", commit.Author)
		fmt.Printf("  type: \"%s\"\n", commit.Type)
		if commit.Tag != "" {
			fmt.Printf("  tag: \"%s\"\n", commit.Tag)
		}
		fmt.Println()
	}

	// Output commits grouped by type
	fmt.Println("by_type:")
	for commitType, typeCommits := range commitsByType {
		fmt.Printf("  %s:\n", commitType)
		for _, commit := range typeCommits {
			fmt.Printf("    - hash: \"%s\"\n", commit.Hash)
			fmt.Printf("      date: \"%s\"\n", commit.Date)
			fmt.Printf("      subject: \"%s\"\n", commit.Subject)
			fmt.Printf("      author: \"%s\"\n", commit.Author)
			if commit.Tag != "" {
				fmt.Printf("      tag: \"%s\"\n", commit.Tag)
			}
		}
		fmt.Println()
	}
}

func getCommits() ([]Commit, error) {
	// Use git log with custom format: fullhash|shorthash|date|subject|author
	cmd := exec.Command("git", "log", "--pretty=format:%H|%h|%ad|%s|%an", "--date=short")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to run git log: %w", err)
	}

	var commits []Commit
	scanner := bufio.NewScanner(strings.NewReader(string(output)))

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		parts := strings.Split(line, "|")
		if len(parts) != 5 {
			continue
		}

		commit := Commit{
			FullHash: parts[0],
			Hash:     parts[1],
			Date:     parts[2],
			Subject:  parts[3],
			Author:   parts[4],
			Type:     extractCommitType(parts[3]),
		}

		commits = append(commits, commit)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading git log output: %w", err)
	}

	return commits, nil
}

func getTags() (map[string]string, error) {
	// Get all tags with their commit hashes (dereference annotated tags)
	cmd := exec.Command("git", "tag", "-l", "--format=%(refname:short)|%(*objectname)")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to run git tag: %w", err)
	}

	tags := make(map[string]string)
	scanner := bufio.NewScanner(strings.NewReader(string(output)))

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		parts := strings.Split(line, "|")
		if len(parts) == 2 {
			tagName := parts[0]
			commitHash := parts[1]
			tags[commitHash] = tagName
		}
	}

	return tags, nil
}

func extractCommitType(subject string) string {
	// Extract commit type from conventional commit format (type: description)
	re := regexp.MustCompile(`^([a-zA-Z]+)(\([^)]+\))?:\s*(.*)`)
	matches := re.FindStringSubmatch(subject)

	if len(matches) >= 2 {
		return matches[1]
	}

	// Fallback to categorizing by keywords
	subjectLower := strings.ToLower(subject)

	switch {
	case strings.Contains(subjectLower, "feat") || strings.Contains(subjectLower, "add"):
		return "feat"
	case strings.Contains(subjectLower, "fix") || strings.Contains(subjectLower, "bug"):
		return "fix"
	case strings.Contains(subjectLower, "doc"):
		return "docs"
	case strings.Contains(subjectLower, "style") || strings.Contains(subjectLower, "format"):
		return "style"
	case strings.Contains(subjectLower, "refactor"):
		return "refactor"
	case strings.Contains(subjectLower, "perf"):
		return "perf"
	case strings.Contains(subjectLower, "test"):
		return "test"
	default:
		return "other"
	}
}

func groupCommitsByType(commits []Commit) map[string][]Commit {
	groups := make(map[string][]Commit)

	for _, commit := range commits {
		groups[commit.Type] = append(groups[commit.Type], commit)
	}

	return groups
}

func groupCommitsByRelease(commits []Commit, tags map[string]string) []Release {
	var releases []Release

	// Get all tag names sorted by version (newest first)
	var taggedCommits []Commit
	for _, commit := range commits {
		if commit.Tag != "" {
			taggedCommits = append(taggedCommits, commit)
		}
	}

	// Check for unversioned commits (commits since the most recent tag)
	if len(taggedCommits) > 0 {
		mostRecentTag := taggedCommits[0]
		unversionedCommits := getCommitsSince(mostRecentTag.Tag)
		if len(unversionedCommits) > 0 {
			release := Release{
				Tag:     "unversioned",
				Hash:    unversionedCommits[0].Hash,
				Date:    unversionedCommits[0].Date,
				Subject: "Unversioned changes",
				Author:  "",
				Commits: unversionedCommits,
			}
			releases = append(releases, release)
		}
	}

	// Process each tagged release
	for i, taggedCommit := range taggedCommits {
		var releaseCommits []Commit

		if i == len(taggedCommits)-1 {
			// This is the oldest tag, get all commits up to and including this tag
			releaseCommits = getCommitsUpTo(taggedCommit.Tag)
		} else {
			// Get commits between this tag and the previous tag
			previousTag := taggedCommits[i+1]
			releaseCommits = getCommitsBetween(previousTag.Tag, taggedCommit.Tag)
		}

		release := Release{
			Tag:     taggedCommit.Tag,
			Hash:    taggedCommit.Hash,
			Date:    taggedCommit.Date,
			Subject: taggedCommit.Subject,
			Author:  taggedCommit.Author,
			Commits: releaseCommits,
		}
		releases = append(releases, release)
	}

	return releases
}

func getCommitsSince(tag string) []Commit {
	// Get commits since the tag (not including the tag itself)
	cmd := exec.Command("git", "log", "--pretty=format:%H|%h|%ad|%s|%an", "--date=short", tag+"..HEAD")
	output, err := cmd.Output()
	if err != nil {
		return nil
	}
	return parseCommitOutput(string(output))
}

func getCommitsBetween(oldTag, newTag string) []Commit {
	// Get commits between two tags (including newTag, excluding oldTag)
	cmd := exec.Command("git", "log", "--pretty=format:%H|%h|%ad|%s|%an", "--date=short", oldTag+".."+newTag)
	output, err := cmd.Output()
	if err != nil {
		return nil
	}
	return parseCommitOutput(string(output))
}

func getCommitsUpTo(tag string) []Commit {
	// Get all commits up to and including the tag
	cmd := exec.Command("git", "log", "--pretty=format:%H|%h|%ad|%s|%an", "--date=short", tag)
	output, err := cmd.Output()
	if err != nil {
		return nil
	}
	return parseCommitOutput(string(output))
}

func parseCommitOutput(output string) []Commit {
	var commits []Commit
	scanner := bufio.NewScanner(strings.NewReader(output))

	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" {
			continue
		}

		parts := strings.Split(line, "|")
		if len(parts) != 5 {
			continue
		}

		commit := Commit{
			FullHash: parts[0],
			Hash:     parts[1],
			Date:     parts[2],
			Subject:  parts[3],
			Author:   parts[4],
			Type:     extractCommitType(parts[3]),
		}

		commits = append(commits, commit)
	}

	return commits
}
