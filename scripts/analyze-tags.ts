import { readdirSync, readFileSync, statSync, writeFileSync } from 'fs';
import { join, relative } from 'path';
import { stringify } from 'yaml';

type Post = {
	path: string;
	title: string;
	current_tags: string[];
	needs_tagging: boolean;
	content_preview: string;
};

type TagsData = {
	all_tags: string[];
	posts: Post[];
};

function getAllFiles(dir: string, fileList: string[] = []): string[] {
	const files = readdirSync(dir);

	files.forEach((file) => {
		const filePath = join(dir, file);
		if (statSync(filePath).isDirectory()) {
			getAllFiles(filePath, fileList);
		} else if (file.endsWith('.svx') && !file.startsWith('_')) {
			fileList.push(filePath);
		}
	});

	return fileList;
}

type Frontmatter = {
	title?: string;
	tags?: string[];
	[key: string]: unknown;
};

function extractFrontmatter(content: string): { frontmatter: Frontmatter; body: string } | null {
	const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
	const match = content.match(frontmatterRegex);

	if (!match) return null;

	const frontmatterText = match[1];
	const body = match[2];

	// Parse frontmatter manually (simple YAML parsing)
	const frontmatter: Frontmatter = {};
	const lines = frontmatterText.split('\n');
	let currentKey: string | null = null;
	let inArray = false;

	lines.forEach((line) => {
		const trimmedLine = line.trim();

		// Skip empty lines
		if (!trimmedLine) return;

		// Handle key-value pairs
		if (trimmedLine.includes(':') && !trimmedLine.startsWith('-')) {
			const colonIndex = trimmedLine.indexOf(':');
			const key = trimmedLine.substring(0, colonIndex).trim();
			const value = trimmedLine.substring(colonIndex + 1).trim();

			currentKey = key;

			// Check if value is an array
			if (value.startsWith('[') && value.endsWith(']')) {
				// Inline array format: tags: ["tag1", "tag2"]
				const arrayContent = value.slice(1, -1);
				frontmatter[key] = arrayContent
					.split(',')
					.map((item) => item.trim().replace(/^["']|["']$/g, ''));
				inArray = false;
			} else if (value === '') {
				// Multi-line array format
				frontmatter[key] = [];
				inArray = true;
			} else {
				// Regular value
				frontmatter[key] = value.replace(/^["']|["']$/g, '');
				inArray = false;
			}
		} else if (trimmedLine.startsWith('-') && inArray && currentKey) {
			// Array item in multi-line format
			const arrayValue = trimmedLine
				.substring(1)
				.trim()
				.replace(/^["']|["']$/g, '');
			frontmatter[currentKey].push(arrayValue);
		}
	});

	return { frontmatter, body };
}

function getContentPreview(body: string, maxLength: number = 500): string {
	// Remove HTML tags and extra whitespace
	const cleanBody = body
		.replace(/<[^>]*>/g, ' ')
		.replace(/\s+/g, ' ')
		.trim();
	return cleanBody.length > maxLength ? cleanBody.substring(0, maxLength) + '...' : cleanBody;
}

function analyzeTags() {
	const contentDir = 'src/content';
	const outputFile = 'src/lib/data/tags.yaml';

	console.log('Scanning content directory...');
	const allFiles = getAllFiles(contentDir);

	const posts: Post[] = [];
	const allTagsSet = new Set<string>();

	allFiles.forEach((filePath) => {
		const content = readFileSync(filePath, 'utf-8');
		const parsed = extractFrontmatter(content);

		if (!parsed) {
			console.warn(`Warning: Could not parse frontmatter in ${filePath}`);
			return;
		}

		const { frontmatter, body } = parsed;
		const tags = Array.isArray(frontmatter.tags) ? frontmatter.tags : [];

		// Add tags to global set
		tags.forEach((tag: string) => allTagsSet.add(tag));

		// Create post entry
		posts.push({
			path: relative(process.cwd(), filePath),
			title: frontmatter.title || 'Untitled',
			current_tags: tags,
			needs_tagging: tags.length === 0,
			content_preview: getContentPreview(body)
		});
	});

	// Sort tags alphabetically
	const allTags = Array.from(allTagsSet).sort();

	// Sort posts by needs_tagging (untagged first), then by path
	posts.sort((a, b) => {
		if (a.needs_tagging !== b.needs_tagging) {
			return a.needs_tagging ? -1 : 1;
		}
		return a.path.localeCompare(b.path);
	});

	const tagsData: TagsData = {
		all_tags: allTags,
		posts
	};

	// Generate YAML with header
	const now = new Date();
	const header = `# Generated by analyze-tags
# Generated on: ${now.toISOString().replace('T', ' ').split('.')[0]}

`;

	const yamlContent = stringify(tagsData);
	writeFileSync(outputFile, header + yamlContent, 'utf-8');

	const untaggedCount = posts.filter((p) => p.needs_tagging).length;
	console.log(`\nAnalysis complete!`);
	console.log(`- Found ${allTags.length} unique tags`);
	console.log(`- Scanned ${posts.length} posts`);
	console.log(`- ${untaggedCount} posts need tagging`);
	console.log(`\nWrote analysis to ${outputFile}`);
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
	analyzeTags();
}

export { analyzeTags };
